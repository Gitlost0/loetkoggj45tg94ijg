[13/11/2017 19:10] ERROR red load_cogs 573: HTTPSConnectionPool(host='api.imgur.com', port=443): Max retries exceeded with url: /3/credits (Caused by NewConnectionError('<urllib3.connection.VerifiedHTTPSConnection object at 0x0000016FDA230D68>: Failed to establish a new connection: [WinError 10060] A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond',))
Traceback (most recent call last):
  File "lib\urllib3\connection.py", line 141, in _new_conn
    (self.host, self.port), self.timeout, **extra_kw)
  File "lib\urllib3\util\connection.py", line 83, in create_connection
    raise err
  File "lib\urllib3\util\connection.py", line 73, in create_connection
    sock.connect(sa)
TimeoutError: [WinError 10060] A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "lib\urllib3\connectionpool.py", line 601, in urlopen
    chunked=chunked)
  File "lib\urllib3\connectionpool.py", line 346, in _make_request
    self._validate_conn(conn)
  File "lib\urllib3\connectionpool.py", line 850, in _validate_conn
    conn.connect()
  File "lib\urllib3\connection.py", line 284, in connect
    conn = self._new_conn()
  File "lib\urllib3\connection.py", line 150, in _new_conn
    self, "Failed to establish a new connection: %s" % e)
urllib3.exceptions.NewConnectionError: <urllib3.connection.VerifiedHTTPSConnection object at 0x0000016FDA230D68>: Failed to establish a new connection: [WinError 10060] A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "lib\requests\adapters.py", line 440, in send
    timeout=timeout
  File "lib\urllib3\connectionpool.py", line 639, in urlopen
    _stacktrace=sys.exc_info()[2])
  File "lib\urllib3\util\retry.py", line 388, in increment
    raise MaxRetryError(_pool, url, error or ResponseError(cause))
urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='api.imgur.com', port=443): Max retries exceeded with url: /3/credits (Caused by NewConnectionError('<urllib3.connection.VerifiedHTTPSConnection object at 0x0000016FDA230D68>: Failed to establish a new connection: [WinError 10060] A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond',))

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "red.py", line 570, in load_cogs
    owner_cog._load_cog(extension)
  File "C:\Users\Owner\Documents\Vbot\Red-DiscordBot\Red-DiscordBot\cogs\owner.py", line 948, in _load_cog
    self.bot.load_extension(mod_obj.__name__)
  File "lib\discord\ext\commands\bot.py", line 738, in load_extension
    lib.setup(self)
  File "C:\Users\Owner\Documents\Vbot\Red-DiscordBot\Red-DiscordBot\cogs\image.py", line 168, in setup
    bot.add_cog(Image(bot))
  File "C:\Users\Owner\Documents\Vbot\Red-DiscordBot\Red-DiscordBot\cogs\image.py", line 22, in __init__
    self.imgur = ImgurClient(CLIENT_ID, CLIENT_SECRET)
  File "lib\imgurpython\client.py", line 85, in __init__
    self.credits = self.get_credits()
  File "lib\imgurpython\client.py", line 94, in get_credits
    return self.make_request('GET', 'credits', None, True)
  File "lib\imgurpython\client.py", line 131, in make_request
    response = method_to_call(url, headers=header, params=data, data=data)
  File "lib\requests\api.py", line 72, in get
    return request('get', url, params=params, **kwargs)
  File "lib\requests\api.py", line 58, in request
    return session.request(method=method, url=url, **kwargs)
  File "lib\requests\sessions.py", line 508, in request
    resp = self.send(prep, **send_kwargs)
  File "lib\requests\sessions.py", line 618, in send
    r = adapter.send(request, **kwargs)
  File "lib\requests\adapters.py", line 508, in send
    raise ConnectionError(e, request=request)
requests.exceptions.ConnectionError: HTTPSConnectionPool(host='api.imgur.com', port=443): Max retries exceeded with url: /3/credits (Caused by NewConnectionError('<urllib3.connection.VerifiedHTTPSConnection object at 0x0000016FDA230D68>: Failed to establish a new connection: [WinError 10060] A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond',))
[13/11/2017 19:10] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "lib\aiohttp\connector.py", line 304, in connect
    yield from self._create_connection(req)
  File "lib\aiohttp\connector.py", line 578, in _create_connection
    transport, proto = yield from self._create_direct_connection(req)
  File "lib\aiohttp\connector.py", line 589, in _create_direct_connection
    hosts = yield from self._resolve_host(req.host, req.port)
  File "lib\aiohttp\connector.py", line 561, in _resolve_host
    self._resolver.resolve(host, port, family=self._family)
  File "lib\aiohttp\resolver.py", line 29, in resolve
    host, port, type=socket.SOCK_STREAM, family=family)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\thread.py", line 55, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\socket.py", line 732, in getaddrinfo
    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
socket.gaierror: [Errno 11001] getaddrinfo failed

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 599, in main
    bot=not bot.settings.self_bot)
  File "lib\discord\client.py", line 416, in login
    yield from getattr(self, '_login_' + str(n))(*args, **kwargs)
  File "lib\discord\client.py", line 346, in _login_1
    data = yield from self.http.static_login(token, bot=is_bot)
  File "lib\discord\http.py", line 258, in static_login
    data = yield from self.request(Route('GET', '/users/@me'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\aiohttp\connector.py", line 314, in connect
    .format(key, exc.strerror)) from exc
aiohttp.errors.ClientOSError: [Errno 11001] Cannot connect to host discordapp.com:443 ssl:True [getaddrinfo failed]
[13/11/2017 19:10] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "lib\aiohttp\connector.py", line 304, in connect
    yield from self._create_connection(req)
  File "lib\aiohttp\connector.py", line 578, in _create_connection
    transport, proto = yield from self._create_direct_connection(req)
  File "lib\aiohttp\connector.py", line 589, in _create_direct_connection
    hosts = yield from self._resolve_host(req.host, req.port)
  File "lib\aiohttp\connector.py", line 561, in _resolve_host
    self._resolver.resolve(host, port, family=self._family)
  File "lib\aiohttp\resolver.py", line 29, in resolve
    host, port, type=socket.SOCK_STREAM, family=family)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\thread.py", line 55, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\socket.py", line 732, in getaddrinfo
    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
socket.gaierror: [Errno 11001] getaddrinfo failed

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 599, in main
    bot=not bot.settings.self_bot)
  File "lib\discord\client.py", line 416, in login
    yield from getattr(self, '_login_' + str(n))(*args, **kwargs)
  File "lib\discord\client.py", line 346, in _login_1
    data = yield from self.http.static_login(token, bot=is_bot)
  File "lib\discord\http.py", line 258, in static_login
    data = yield from self.request(Route('GET', '/users/@me'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\aiohttp\connector.py", line 314, in connect
    .format(key, exc.strerror)) from exc
aiohttp.errors.ClientOSError: [Errno 11001] Cannot connect to host discordapp.com:443 ssl:True [getaddrinfo failed]
[13/11/2017 19:11] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "lib\aiohttp\connector.py", line 304, in connect
    yield from self._create_connection(req)
  File "lib\aiohttp\connector.py", line 578, in _create_connection
    transport, proto = yield from self._create_direct_connection(req)
  File "lib\aiohttp\connector.py", line 589, in _create_direct_connection
    hosts = yield from self._resolve_host(req.host, req.port)
  File "lib\aiohttp\connector.py", line 561, in _resolve_host
    self._resolver.resolve(host, port, family=self._family)
  File "lib\aiohttp\resolver.py", line 29, in resolve
    host, port, type=socket.SOCK_STREAM, family=family)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\thread.py", line 55, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\socket.py", line 732, in getaddrinfo
    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
socket.gaierror: [Errno 11001] getaddrinfo failed

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 599, in main
    bot=not bot.settings.self_bot)
  File "lib\discord\client.py", line 416, in login
    yield from getattr(self, '_login_' + str(n))(*args, **kwargs)
  File "lib\discord\client.py", line 346, in _login_1
    data = yield from self.http.static_login(token, bot=is_bot)
  File "lib\discord\http.py", line 258, in static_login
    data = yield from self.request(Route('GET', '/users/@me'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\aiohttp\connector.py", line 314, in connect
    .format(key, exc.strerror)) from exc
aiohttp.errors.ClientOSError: [Errno 11001] Cannot connect to host discordapp.com:443 ssl:True [getaddrinfo failed]
[13/11/2017 19:11] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "lib\aiohttp\connector.py", line 304, in connect
    yield from self._create_connection(req)
  File "lib\aiohttp\connector.py", line 578, in _create_connection
    transport, proto = yield from self._create_direct_connection(req)
  File "lib\aiohttp\connector.py", line 589, in _create_direct_connection
    hosts = yield from self._resolve_host(req.host, req.port)
  File "lib\aiohttp\connector.py", line 561, in _resolve_host
    self._resolver.resolve(host, port, family=self._family)
  File "lib\aiohttp\resolver.py", line 29, in resolve
    host, port, type=socket.SOCK_STREAM, family=family)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\thread.py", line 55, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\socket.py", line 732, in getaddrinfo
    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
socket.gaierror: [Errno 11001] getaddrinfo failed

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 599, in main
    bot=not bot.settings.self_bot)
  File "lib\discord\client.py", line 416, in login
    yield from getattr(self, '_login_' + str(n))(*args, **kwargs)
  File "lib\discord\client.py", line 346, in _login_1
    data = yield from self.http.static_login(token, bot=is_bot)
  File "lib\discord\http.py", line 258, in static_login
    data = yield from self.request(Route('GET', '/users/@me'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\aiohttp\connector.py", line 314, in connect
    .format(key, exc.strerror)) from exc
aiohttp.errors.ClientOSError: [Errno 11001] Cannot connect to host discordapp.com:443 ssl:True [getaddrinfo failed]
[13/11/2017 19:11] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "lib\aiohttp\connector.py", line 304, in connect
    yield from self._create_connection(req)
  File "lib\aiohttp\connector.py", line 578, in _create_connection
    transport, proto = yield from self._create_direct_connection(req)
  File "lib\aiohttp\connector.py", line 589, in _create_direct_connection
    hosts = yield from self._resolve_host(req.host, req.port)
  File "lib\aiohttp\connector.py", line 561, in _resolve_host
    self._resolver.resolve(host, port, family=self._family)
  File "lib\aiohttp\resolver.py", line 29, in resolve
    host, port, type=socket.SOCK_STREAM, family=family)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\thread.py", line 55, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\socket.py", line 732, in getaddrinfo
    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
socket.gaierror: [Errno 11001] getaddrinfo failed

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 599, in main
    bot=not bot.settings.self_bot)
  File "lib\discord\client.py", line 416, in login
    yield from getattr(self, '_login_' + str(n))(*args, **kwargs)
  File "lib\discord\client.py", line 346, in _login_1
    data = yield from self.http.static_login(token, bot=is_bot)
  File "lib\discord\http.py", line 258, in static_login
    data = yield from self.request(Route('GET', '/users/@me'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\aiohttp\connector.py", line 314, in connect
    .format(key, exc.strerror)) from exc
aiohttp.errors.ClientOSError: [Errno 11001] Cannot connect to host discordapp.com:443 ssl:True [getaddrinfo failed]
[13/11/2017 19:11] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "lib\aiohttp\connector.py", line 304, in connect
    yield from self._create_connection(req)
  File "lib\aiohttp\connector.py", line 578, in _create_connection
    transport, proto = yield from self._create_direct_connection(req)
  File "lib\aiohttp\connector.py", line 589, in _create_direct_connection
    hosts = yield from self._resolve_host(req.host, req.port)
  File "lib\aiohttp\connector.py", line 561, in _resolve_host
    self._resolver.resolve(host, port, family=self._family)
  File "lib\aiohttp\resolver.py", line 29, in resolve
    host, port, type=socket.SOCK_STREAM, family=family)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\thread.py", line 55, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\socket.py", line 732, in getaddrinfo
    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
socket.gaierror: [Errno 11001] getaddrinfo failed

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 599, in main
    bot=not bot.settings.self_bot)
  File "lib\discord\client.py", line 416, in login
    yield from getattr(self, '_login_' + str(n))(*args, **kwargs)
  File "lib\discord\client.py", line 346, in _login_1
    data = yield from self.http.static_login(token, bot=is_bot)
  File "lib\discord\http.py", line 258, in static_login
    data = yield from self.request(Route('GET', '/users/@me'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\aiohttp\connector.py", line 314, in connect
    .format(key, exc.strerror)) from exc
aiohttp.errors.ClientOSError: [Errno 11001] Cannot connect to host discordapp.com:443 ssl:True [getaddrinfo failed]
[13/11/2017 19:11] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "lib\aiohttp\connector.py", line 304, in connect
    yield from self._create_connection(req)
  File "lib\aiohttp\connector.py", line 578, in _create_connection
    transport, proto = yield from self._create_direct_connection(req)
  File "lib\aiohttp\connector.py", line 589, in _create_direct_connection
    hosts = yield from self._resolve_host(req.host, req.port)
  File "lib\aiohttp\connector.py", line 561, in _resolve_host
    self._resolver.resolve(host, port, family=self._family)
  File "lib\aiohttp\resolver.py", line 29, in resolve
    host, port, type=socket.SOCK_STREAM, family=family)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\thread.py", line 55, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\socket.py", line 732, in getaddrinfo
    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
socket.gaierror: [Errno 11001] getaddrinfo failed

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 599, in main
    bot=not bot.settings.self_bot)
  File "lib\discord\client.py", line 416, in login
    yield from getattr(self, '_login_' + str(n))(*args, **kwargs)
  File "lib\discord\client.py", line 346, in _login_1
    data = yield from self.http.static_login(token, bot=is_bot)
  File "lib\discord\http.py", line 258, in static_login
    data = yield from self.request(Route('GET', '/users/@me'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\aiohttp\connector.py", line 314, in connect
    .format(key, exc.strerror)) from exc
aiohttp.errors.ClientOSError: [Errno 11001] Cannot connect to host discordapp.com:443 ssl:True [getaddrinfo failed]
[13/11/2017 19:12] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "lib\aiohttp\connector.py", line 304, in connect
    yield from self._create_connection(req)
  File "lib\aiohttp\connector.py", line 578, in _create_connection
    transport, proto = yield from self._create_direct_connection(req)
  File "lib\aiohttp\connector.py", line 589, in _create_direct_connection
    hosts = yield from self._resolve_host(req.host, req.port)
  File "lib\aiohttp\connector.py", line 561, in _resolve_host
    self._resolver.resolve(host, port, family=self._family)
  File "lib\aiohttp\resolver.py", line 29, in resolve
    host, port, type=socket.SOCK_STREAM, family=family)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\thread.py", line 55, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\socket.py", line 732, in getaddrinfo
    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
socket.gaierror: [Errno 11001] getaddrinfo failed

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 599, in main
    bot=not bot.settings.self_bot)
  File "lib\discord\client.py", line 416, in login
    yield from getattr(self, '_login_' + str(n))(*args, **kwargs)
  File "lib\discord\client.py", line 346, in _login_1
    data = yield from self.http.static_login(token, bot=is_bot)
  File "lib\discord\http.py", line 258, in static_login
    data = yield from self.request(Route('GET', '/users/@me'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\aiohttp\connector.py", line 314, in connect
    .format(key, exc.strerror)) from exc
aiohttp.errors.ClientOSError: [Errno 11001] Cannot connect to host discordapp.com:443 ssl:True [getaddrinfo failed]
[14/11/2017 21:23] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "lib\aiohttp\connector.py", line 304, in connect
    yield from self._create_connection(req)
  File "lib\aiohttp\connector.py", line 578, in _create_connection
    transport, proto = yield from self._create_direct_connection(req)
  File "lib\aiohttp\connector.py", line 589, in _create_direct_connection
    hosts = yield from self._resolve_host(req.host, req.port)
  File "lib\aiohttp\connector.py", line 561, in _resolve_host
    self._resolver.resolve(host, port, family=self._family)
  File "lib\aiohttp\resolver.py", line 29, in resolve
    host, port, type=socket.SOCK_STREAM, family=family)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\thread.py", line 55, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\socket.py", line 732, in getaddrinfo
    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
socket.gaierror: [Errno 11001] getaddrinfo failed

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 599, in main
    bot=not bot.settings.self_bot)
  File "lib\discord\client.py", line 416, in login
    yield from getattr(self, '_login_' + str(n))(*args, **kwargs)
  File "lib\discord\client.py", line 346, in _login_1
    data = yield from self.http.static_login(token, bot=is_bot)
  File "lib\discord\http.py", line 258, in static_login
    data = yield from self.request(Route('GET', '/users/@me'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\aiohttp\connector.py", line 314, in connect
    .format(key, exc.strerror)) from exc
aiohttp.errors.ClientOSError: [Errno 11001] Cannot connect to host discordapp.com:443 ssl:True [getaddrinfo failed]
[14/11/2017 21:24] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "lib\aiohttp\connector.py", line 304, in connect
    yield from self._create_connection(req)
  File "lib\aiohttp\connector.py", line 578, in _create_connection
    transport, proto = yield from self._create_direct_connection(req)
  File "lib\aiohttp\connector.py", line 589, in _create_direct_connection
    hosts = yield from self._resolve_host(req.host, req.port)
  File "lib\aiohttp\connector.py", line 561, in _resolve_host
    self._resolver.resolve(host, port, family=self._family)
  File "lib\aiohttp\resolver.py", line 29, in resolve
    host, port, type=socket.SOCK_STREAM, family=family)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\thread.py", line 55, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\socket.py", line 732, in getaddrinfo
    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
socket.gaierror: [Errno 11001] getaddrinfo failed

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 599, in main
    bot=not bot.settings.self_bot)
  File "lib\discord\client.py", line 416, in login
    yield from getattr(self, '_login_' + str(n))(*args, **kwargs)
  File "lib\discord\client.py", line 346, in _login_1
    data = yield from self.http.static_login(token, bot=is_bot)
  File "lib\discord\http.py", line 258, in static_login
    data = yield from self.request(Route('GET', '/users/@me'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\aiohttp\connector.py", line 314, in connect
    .format(key, exc.strerror)) from exc
aiohttp.errors.ClientOSError: [Errno 11001] Cannot connect to host discordapp.com:443 ssl:True [getaddrinfo failed]
[14/11/2017 21:24] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "lib\aiohttp\connector.py", line 304, in connect
    yield from self._create_connection(req)
  File "lib\aiohttp\connector.py", line 578, in _create_connection
    transport, proto = yield from self._create_direct_connection(req)
  File "lib\aiohttp\connector.py", line 589, in _create_direct_connection
    hosts = yield from self._resolve_host(req.host, req.port)
  File "lib\aiohttp\connector.py", line 561, in _resolve_host
    self._resolver.resolve(host, port, family=self._family)
  File "lib\aiohttp\resolver.py", line 29, in resolve
    host, port, type=socket.SOCK_STREAM, family=family)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\thread.py", line 55, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\socket.py", line 732, in getaddrinfo
    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
socket.gaierror: [Errno 11001] getaddrinfo failed

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 599, in main
    bot=not bot.settings.self_bot)
  File "lib\discord\client.py", line 416, in login
    yield from getattr(self, '_login_' + str(n))(*args, **kwargs)
  File "lib\discord\client.py", line 346, in _login_1
    data = yield from self.http.static_login(token, bot=is_bot)
  File "lib\discord\http.py", line 258, in static_login
    data = yield from self.request(Route('GET', '/users/@me'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\aiohttp\connector.py", line 314, in connect
    .format(key, exc.strerror)) from exc
aiohttp.errors.ClientOSError: [Errno 11001] Cannot connect to host discordapp.com:443 ssl:True [getaddrinfo failed]
[14/11/2017 21:24] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "lib\aiohttp\connector.py", line 304, in connect
    yield from self._create_connection(req)
  File "lib\aiohttp\connector.py", line 578, in _create_connection
    transport, proto = yield from self._create_direct_connection(req)
  File "lib\aiohttp\connector.py", line 589, in _create_direct_connection
    hosts = yield from self._resolve_host(req.host, req.port)
  File "lib\aiohttp\connector.py", line 561, in _resolve_host
    self._resolver.resolve(host, port, family=self._family)
  File "lib\aiohttp\resolver.py", line 29, in resolve
    host, port, type=socket.SOCK_STREAM, family=family)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\thread.py", line 55, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\socket.py", line 732, in getaddrinfo
    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
socket.gaierror: [Errno 11001] getaddrinfo failed

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 599, in main
    bot=not bot.settings.self_bot)
  File "lib\discord\client.py", line 416, in login
    yield from getattr(self, '_login_' + str(n))(*args, **kwargs)
  File "lib\discord\client.py", line 346, in _login_1
    data = yield from self.http.static_login(token, bot=is_bot)
  File "lib\discord\http.py", line 258, in static_login
    data = yield from self.request(Route('GET', '/users/@me'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\aiohttp\connector.py", line 314, in connect
    .format(key, exc.strerror)) from exc
aiohttp.errors.ClientOSError: [Errno 11001] Cannot connect to host discordapp.com:443 ssl:True [getaddrinfo failed]
[14/11/2017 21:25] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\selector_events.py", line 669, in _read_ready
    data = self._sock.recv(self.max_size)
ConnectionResetError: [WinError 10054] An existing connection was forcibly closed by the remote host

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "lib\aiohttp\client.py", line 202, in _request
    yield from resp.start(conn, read_until_eof)
  File "lib\aiohttp\client_reqrep.py", line 640, in start
    message = yield from httpstream.read()
  File "lib\aiohttp\streams.py", line 641, in read
    result = yield from super().read()
  File "lib\aiohttp\streams.py", line 476, in read
    yield from self._waiter
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
aiohttp.errors.ServerDisconnectedError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 599, in main
    bot=not bot.settings.self_bot)
  File "lib\discord\client.py", line 416, in login
    yield from getattr(self, '_login_' + str(n))(*args, **kwargs)
  File "lib\discord\client.py", line 346, in _login_1
    data = yield from self.http.static_login(token, bot=is_bot)
  File "lib\discord\http.py", line 258, in static_login
    data = yield from self.request(Route('GET', '/users/@me'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 209, in _request
    raise aiohttp.ClientResponseError() from exc
aiohttp.errors.ClientResponseError
[14/11/2017 21:28] ERROR red on_command_error 369: Exception in command 'help'
Traceback (most recent call last):
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\selector_events.py", line 669, in _read_ready
    data = self._sock.recv(self.max_size)
ConnectionResetError: [WinError 10054] An existing connection was forcibly closed by the remote host

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "lib\aiohttp\client.py", line 202, in _request
    yield from resp.start(conn, read_until_eof)
  File "lib\aiohttp\client_reqrep.py", line 640, in start
    message = yield from httpstream.read()
  File "lib\aiohttp\streams.py", line 641, in read
    result = yield from super().read()
  File "lib\aiohttp\streams.py", line 476, in read
    yield from self._waiter
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
aiohttp.errors.ServerDisconnectedError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "lib\discord\ext\commands\core.py", line 50, in wrapped
    ret = yield from coro(*args, **kwargs)
  File "lib\discord\ext\commands\bot.py", line 143, in _default_help_command
    yield from bot.send_message(destination, page)
  File "red.py", line 92, in send_message
    return await super().send_message(*args, **kwargs)
  File "lib\discord\client.py", line 1151, in send_message
    data = yield from self.http.send_message(channel_id, content, guild_id=guild_id, tts=tts, embed=embed)
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 209, in _request
    raise aiohttp.ClientResponseError() from exc
aiohttp.errors.ClientResponseError
[15/11/2017 20:34] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\aiohttp\connector.py", line 304, in connect
    yield from self._create_connection(req)
  File "lib\aiohttp\connector.py", line 578, in _create_connection
    transport, proto = yield from self._create_direct_connection(req)
  File "lib\aiohttp\connector.py", line 601, in _create_direct_connection
    local_addr=self._local_addr)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 713, in create_connection
    sock, protocol_factory, ssl, server_hostname)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 736, in _create_connection_transport
    yield from waiter
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 266, in result
    raise CancelledError
concurrent.futures._base.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 603, in main
    yield from bot.connect()
  File "lib\discord\client.py", line 451, in connect
    self.ws = yield from DiscordWebSocket.from_client(self, resume=True)
  File "lib\discord\gateway.py", line 198, in from_client
    gateway = yield from client.http.get_gateway()
  File "lib\discord\http.py", line 633, in get_gateway
    data = yield from self.request(Route('GET', '/gateway'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\async_timeout\__init__.py", line 35, in __exit__
    self._do_exit(exc_type)
  File "lib\async_timeout\__init__.py", line 80, in _do_exit
    raise asyncio.TimeoutError
concurrent.futures._base.TimeoutError
[15/11/2017 20:39] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\aiohttp\connector.py", line 304, in connect
    yield from self._create_connection(req)
  File "lib\aiohttp\connector.py", line 578, in _create_connection
    transport, proto = yield from self._create_direct_connection(req)
  File "lib\aiohttp\connector.py", line 601, in _create_direct_connection
    local_addr=self._local_addr)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 713, in create_connection
    sock, protocol_factory, ssl, server_hostname)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 736, in _create_connection_transport
    yield from waiter
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 266, in result
    raise CancelledError
concurrent.futures._base.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 599, in main
    bot=not bot.settings.self_bot)
  File "lib\discord\client.py", line 416, in login
    yield from getattr(self, '_login_' + str(n))(*args, **kwargs)
  File "lib\discord\client.py", line 346, in _login_1
    data = yield from self.http.static_login(token, bot=is_bot)
  File "lib\discord\http.py", line 258, in static_login
    data = yield from self.request(Route('GET', '/users/@me'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\async_timeout\__init__.py", line 35, in __exit__
    self._do_exit(exc_type)
  File "lib\async_timeout\__init__.py", line 80, in _do_exit
    raise asyncio.TimeoutError
concurrent.futures._base.TimeoutError
[15/11/2017 20:45] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\aiohttp\connector.py", line 304, in connect
    yield from self._create_connection(req)
  File "lib\aiohttp\connector.py", line 578, in _create_connection
    transport, proto = yield from self._create_direct_connection(req)
  File "lib\aiohttp\connector.py", line 601, in _create_direct_connection
    local_addr=self._local_addr)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 713, in create_connection
    sock, protocol_factory, ssl, server_hostname)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 736, in _create_connection_transport
    yield from waiter
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 266, in result
    raise CancelledError
concurrent.futures._base.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 599, in main
    bot=not bot.settings.self_bot)
  File "lib\discord\client.py", line 416, in login
    yield from getattr(self, '_login_' + str(n))(*args, **kwargs)
  File "lib\discord\client.py", line 346, in _login_1
    data = yield from self.http.static_login(token, bot=is_bot)
  File "lib\discord\http.py", line 258, in static_login
    data = yield from self.request(Route('GET', '/users/@me'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\async_timeout\__init__.py", line 35, in __exit__
    self._do_exit(exc_type)
  File "lib\async_timeout\__init__.py", line 80, in _do_exit
    raise asyncio.TimeoutError
concurrent.futures._base.TimeoutError
[15/11/2017 20:50] ERROR red <module> 634: Fatal exception, attempting graceful logout
Traceback (most recent call last):
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\aiohttp\connector.py", line 304, in connect
    yield from self._create_connection(req)
  File "lib\aiohttp\connector.py", line 578, in _create_connection
    transport, proto = yield from self._create_direct_connection(req)
  File "lib\aiohttp\connector.py", line 601, in _create_direct_connection
    local_addr=self._local_addr)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 713, in create_connection
    sock, protocol_factory, ssl, server_hostname)
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 736, in _create_connection_transport
    yield from waiter
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 296, in _wakeup
    future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 266, in result
    raise CancelledError
concurrent.futures._base.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "red.py", line 614, in <module>
    loop.run_until_complete(main(bot))
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\base_events.py", line 387, in run_until_complete
    return future.result()
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\futures.py", line 274, in result
    raise self._exception
  File "C:\Users\Owner\AppData\Local\Programs\Python\Python35\lib\asyncio\tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "red.py", line 599, in main
    bot=not bot.settings.self_bot)
  File "lib\discord\client.py", line 416, in login
    yield from getattr(self, '_login_' + str(n))(*args, **kwargs)
  File "lib\discord\client.py", line 346, in _login_1
    data = yield from self.http.static_login(token, bot=is_bot)
  File "lib\discord\http.py", line 258, in static_login
    data = yield from self.request(Route('GET', '/users/@me'))
  File "lib\discord\http.py", line 137, in request
    r = yield from self.session.request(method, url, **kwargs)
  File "lib\aiohttp\client.py", line 555, in __iter__
    resp = yield from self._coro
  File "lib\aiohttp\client.py", line 198, in _request
    conn = yield from self._connector.connect(req)
  File "lib\async_timeout\__init__.py", line 35, in __exit__
    self._do_exit(exc_type)
  File "lib\async_timeout\__init__.py", line 80, in _do_exit
    raise asyncio.TimeoutError
concurrent.futures._base.TimeoutError
